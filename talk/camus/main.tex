\def\macrosUseBeamer{}
\input{arthur}
\input{macros}

\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{multicol}

\newcommand\tab{$\hphantom{--}$}

\begin{document}

% No 'Figure' in captions
\setbeamertemplate{caption}{\raggedright\insertcaption\par}

%******************************************************************************
%******************************************************************************
%******************************************************************************

\title{Verification of Data Layout Transformations}
\author[Ramon Fern\'{a}ndez Mir]{{\bf Ramon Fern\'{a}ndez Mir}\\ \vspace{1em} with Arthur Chargu√©raud }
\institute[]{Inria}
\date{17/09/2018}

\frame{\titlepage}

%******************************************************************************
%\framecontentdocument

%******************************************************************************
%******************************************************************************
%******************************************************************************
%\section{Separation Logic: a first example}

%\framecontentsection


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Software verification}

Why do we care? Take for example GCC.
\begin{itemize}
	\item Between 1999 and 2015, over 39.000 bugs were reported.
	\item Approximately 60\% of the files have some sort of bug.
	\item The life span of a bug is 200 days.
	\item The most buggy file (as of 2015) had 817 different bugs. 
\end{itemize}

\bigskip \pause

\textbf{Solution:} The CompCert verified compiler.
\begin{figure}[H]
\centering
\includegraphics[width=7cm]{images/compcert}
\end{figure}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example}

\begin{figure}[H]
\centering
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/ITER_tokamak}
\caption{\footnotesize ITER tokamak}
\label{fig:figure1}
\end{minipage}%
\hspace{0.5cm}
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/plasma_physics}
\caption{\footnotesize Plasma physics}
\label{fig:figure2}
\end{minipage}%
\hspace{0.5cm}
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/PIC_simulation}
\caption{\footnotesize PIC simulation}
\label{fig:figure2}
\end{minipage}
\end{figure}

\bigskip

Challenges:
\begin{itemize}
	\item Exploit data-level parallelism.
	\item Use domain-specific knowledge of the code.
	\item Do it without introducing any bugs.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - initial code}

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    // Position
    float x, y, z;
    // Other fields
    float vx, vy, vz, c, m, v;
  } particle;

  particle data[N];

  for (int i = 0; i < N; i++) {
    // Some calculation involving data[i]
  }
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - splitting}

Suppose that the calculation uses mainly the position.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
    cold_fields *other;
  } particle;

  particle data[N];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - peeling}

%Further suppose that the intial `particle' record is not used as part of a dynamic data structure.
Typically, cold fields are stored in a different array.

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
  } hot_fields;

  cold_fields other_data[N];
  hot_fields pos_data[N];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to SoA}

Now, say that we want to take advantage of vector instructions.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[N];
    float y[N];
    float z[N];
  } hot_fields;

  hot_fields pos_data;
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to AoSoA}

But without reducing too much the locality between accesses to fields of the original struct.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[B];
    float y[B];
    float z[B];
  } hot_fields;

  hot_fields pos_data[ceil(N/B)];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - summary}

In short, the transformations we have seen are:
\begin{itemize}
	\item Splitting.
	\item Peeling.
	\item AoS to SoA.
	\item AoS to AoSoA.
\end{itemize}

\bigskip \pause

E.g., when applying all these transformations, an access of the form:

\begin{lstlisting}[style=Cstyle]
  data[i].x
\end{lstlisting}

becomes:

\begin{lstlisting}[style=Cstyle]
  pos_data[i/B].x[i%B]
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Project goals}

\begin{itemize}
	\setlength\itemsep{1.5em}
	\item Find the basic transformations that combined give rise to the ones we are interested in.\\ \pause
	\item Formalize a C-like language with arrays, structs and pointers.
	\begin{itemize}
		\item Equipped with a high-level semantics, to simplify the proofs.
		\item Equipped with a low-level semantics, to be closer to C.
	\end{itemize} \pause
	\item Define the transformations and prove their correctness.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations -- overview}

\begin{center}
\begin{minipage}{0.45\linewidth}
\textbf{\small 1. Field grouping}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b, c;
} s;

// After
typedef struct {
  int b, c;
} sg;

typedef struct {
  int a; sg fg;
} s';
\end{lstlisting}
\textbf{\small 2. Array tiling}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef int a[N];

// After
typedef int a'[N/B][B];
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.45\linewidth}
\textbf{\small 3. AoS to SoA}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a[N]; int b[N];
} s';
\end{lstlisting}
\textbf{\small 4. Adding indirection}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a; T b;
} s;

// After
typedef struct {
  int a; T *b;
} s';
\end{lstlisting}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - grouping}

\begin{center}
\begin{minipage}{0.3\linewidth}
\textbf{\small 1. Field grouping}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b, c;
} s;

// After
typedef struct {
  int b, c;
} sg;

typedef struct {
  int a; sg fg;
} s';
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{images/grouping}
\end{figure}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - tiling}

\begin{center}
\begin{minipage}{0.3\linewidth}
\textbf{\small 2. Array tiling}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef int a[N];

// After
typedef int a'[N/B][B];
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{images/tiling}
\end{figure}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - AoS to SoA}

\begin{center}
\begin{minipage}{0.3\linewidth}
\textbf{\small 3. AoS to SoA}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a[N]; int b[N];
} s';
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{images/soa}
\end{figure}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - indirection}

\begin{center}
\begin{minipage}{0.3\linewidth}
\textbf{\small 4. Adding indirection}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a; T b;
} s;

// After
typedef struct {
  int a; T *b;
} s';
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{images/indirection}
\end{figure}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - justification}

\begin{itemize}
	\setlength\itemsep{1.5em}	\item \textbf{Splitting:} Field grouping and then adding indirection on the field holding the group. %\pause
	\item \textbf{Peeling:} Field grouping twice. %\pause
	\item \textbf{AoS to SoA:} AoS to SoA. %\pause
	\item \textbf{AoS to AoSoA:} Array tiling and then AoS to SoA on the tiles.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview}

\begin{figure}[H]
\centering
\includegraphics[width=7cm]{images/compcert_our_language}
\end{figure}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Field grouping - rules}



\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Field grouping - theorem}

In the end the theorem that we prove for full executions is:

\begin{coq}
  Theorem red_tr: forall gt C C' t t' v m,
    red C empty_stack empty_state t m v ->
    ~ is_error v ->
    group_tr_ok gt C ->
    tr_typdefctx gt C C' ->
    tr_trm gt t t' ->
    wf_typdefctx C ->
    wf_trm C t ->
    exists v' m',		tr_val gt v v'
	  	   /\ tr_state gt m m'
		   /\ red C' empty_stack empty_state t' m' v'.
\end{coq}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Field grouping - induction}

To make the proof work we strengthen it as follows:

\begin{coq}
  Theorem red_tr_ind: forall gt C C' t t' v S S' m1 m1' m2,
    red C S m1 t m2 v ->
    ~ is_error v ->
    group_tr_ok gt C ->
    tr_typdefctx gt C C' ->
    tr_trm gt t t' ->
    tr_stack gt S S' ->
    tr_state gt m1 m1' ->
    wf_typdefctx C ->
    wf_trm C t ->
    wf_stack C S ->
    wf_state C m1 ->
    exists v' m2',				tr_val gt v v'
			  /\	tr_state gt m2 m2'
			  /\	red C' S' m1' t' m2' v'.
\end{coq}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Array tiling}

We need to know:
\begin{itemize}
	\item The name of the array being changed (\texttt{Ta}).
	\item The new name for the tiles (\texttt{Tt}).
	\item The size of the tiles (\texttt{K}).
\end{itemize}

\bigskip \pause

Similarly, we also define:
\\[0.75em]
\begin{minipage}{0.45\linewidth}
\begin{itemize}
	\item \texttt{tiling\_tr\_ok},
	\item \texttt{tr\_typdefctx},
	\item \texttt{tr\_accesses},
	\item \texttt{tr\_val},
\end{itemize}
\end{minipage}%
\begin{minipage}{0.45\linewidth}
\begin{itemize}
	\item \texttt{tr\_stack},
	\item \texttt{tr\_state} and
	\item \texttt{tr\_trm}.
\end{itemize}
\end{minipage}

\bigskip

In this case, we change all the instances of \texttt{t[i]} to \texttt{t[i/K][i\%K]} where \texttt{t} has type \texttt{typ\_var Ta}.

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Array tiling - some specifics}

We use:
\begin{itemize}
	\item \texttt{I} for the length of the original array,
	\item \texttt{J} for the length of the array of tiles and
	\item \texttt{K} for the length of the tile.
\end{itemize}

\bigskip

These are related by the definitions:

\begin{coq}
  Definition nb_tiles (K I J:int) : Prop :=
    J = I / K + If (I mod K = 0) then 0 else 1.

  Definition tiled_indices (I J K i j k:int) : Prop :=
  		i = j * K + k
	/\	index I i
	/\	index J j
  	/\	index K k.
\end{coq}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Array tiling - key components}



The crucial case of \texttt{tr\_val} from the array \texttt{aI} to \texttt{aJ} is captured by:

\begin{coqs}
  forall i j k aK,			tiled_indices I J K i j k ->
				  aJ[j] = (val_array (typ_var Tt) aK) ->
				  tr_val tt aI[i] aK[k]
\end{coqs}

\bigskip \pause

For the translation accesses and primitive operations, the aim is for all the accesses of the form:

\begin{coqs}
  l1 ++ (access_array (typ_var Ta) i)::l2
\end{coqs}

to be transformed to:

\begin{coqs}
  l1 ++ (access_array (typ_var Ta) (i/K))::(access_array (typ_var Tt) (i mod K))::l2.
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{AoS to SoA}

For this transformation, we need to know:
\begin{itemize}
	\item The name of the array being changed (\texttt{Ta}).
	\item The fields names and types of the struct being changed (\texttt{Tfs}).
	\item The size of the array (\texttt{K}).
\end{itemize}

\bigskip \pause

This transformation is similar to array tiling in many ways. One key difference is that the accesses
of the form:

\begin{coqs}
  l1 ++ (access_array Ta i)::(access_field (typ_struct Tfs) f)::l2
\end{coqs}

are transformed to:

\begin{coqs}
  l1 ++ (access_field Ta f)::(access_field (typ_array Tfs[f] K) i)::l2.
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{High-level transformations - summary}

So far we have presented:

\vspace{1em}
\begin{itemize}
	\setlength\itemsep{1.5em}
	\item Field grouping.
	\item Array tiling.
	\item AoS to SoA.
\end{itemize}

\bigskip \pause

The correctness of these is proved! \\ %\pause
(up to a couple axioms, e.g., results on the modulo operation)

\bigskip \pause

\textbf{Problem}: This might all be just a hack if we don't link it with a more concrete, CompCert-style semantics...

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{High-level to low-level transformation}

The grammar is extended with:

\begin{coqs}
  Inductive val : Type :=
    | val_concrete_ptr : loc -> val
    | val_words : list word -> val.

  Inductive prim : Type :=
    | prim_ll_get : typ -> prim
    | prim_ll_set : typ -> prim
    | prim_ll_new : typ -> prim
    | prim_ll_access : typ -> prim.
\end{coqs}

%ARTHUR: move LL_context here
\bigskip \pause

There are two sides of this transformation:
\begin{itemize}
	\item The memory.
	\item The programs.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{High-level to low-level transformation - memory}

\begin{center}

\begin{figure}
	\includegraphics[scale=0.31]{images/high_level_memory}
	\caption{High-level memory.}
\end{figure}

\begin{figure}
	\includegraphics[scale=0.31]{images/low_level_memory}
	\caption{Low-level memory.}
\end{figure}

\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{High-level to low-level transformation - program}

The values in the source code  are all kept the same except for pointers:

\begin{coqs}
  Inductive tr_val (C:typdefctx) (LLC:ll_typdefctx) (a:alpha) : val -> val -> Prop :=
	  | tr_val_abstract_ptr : forall p l o,
          tr_ll_accesses C LLC p o ->
      	  tr_val C LLC a (val_abstract_ptr l p) (val_concrete_ptr (a[l] + o)).
\end{coqs}

\bigskip \pause

For terms, as an example, a term:

\begin{coqs}
  trm_app (prim_struct_access T f) (t::nil)
\end{coqs}

gets translated to:

\begin{coqs}
  trm_app (prim_ll_access T[f]) (t'::(field_offset T f)::nil).
\end{coqs}

\bigskip \pause

The semantics of \texttt{prim\_ll\_access} is, in fact, that of addition.

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{High-level to low-level transformation - LLC}

The low-level context is defined as follows:

\begin{coqs}
  Record ll_typdefctx := make_ll_typdefctx {
    typvar_sizes				: map typvar size;
    fields_offsets	: map typvar (map field offset);
    fields_order				: map typvar (list field) }.
\end{coqs}

We need to ensure coherency between the type definition context (\texttt{C}) and the low-level context (\texttt{LLC}). In particular:

\begin{itemize}
	\item The type variable sizes in \texttt{LLC} match with the types in \texttt{C}.
	\item The field offsets match with the order of the fields and the sizes of each of their types.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{High-level to low-level transformation - theorem}

The goal is to prove:
\begin{coq}
Theorem red_tr_warmup : forall C LLC T m a v t' m' v',
  red C LLC empty_stack empty_state t m v ->
  typing C empty_gamma empty_phi t T ->
  ~ is_error v ->
  ll_typdefctx_ok C LLC ->
  tr_trm C LLC a t t' ->
  wf_typdefctx C ->
  wf_trm C t ->
  wf_typ C T ->
  exists v' m',		tr_state C LLC a m m'
  		 /\ tr_val C LLC a v v'
  		 /\ red C LLC empty_stack empty_state t' m' v'.
\end{coq}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Project extent}

Accomplished goals:
\\[0.7em]
\begin{itemize}
	\setlength\itemsep{1.2em}
	\item Defined a high-level language convenient to argue about data-layout transformations. \pause
	\item Found a way to connect it to realistic low-level semantics. \pause
	\item Basically proved the correctness of:
	\begin{itemize}
		\item Field grouping.
		\item Array tiling.
		\item AoS to SoA.
	\end{itemize}
\end{itemize}

\bigskip \pause

Some statistics:
\begin{center}
\begin{tabular}{ccc}
lines of spec & lines of proof & lines of comments \\
2723 & 3103 & 668
\end{tabular}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Future work}

Next steps:
\\[0.7em]
\begin{itemize}
	\setlength\itemsep{1.5em}
	\item Formalization of the transformation `adding indirection'. %\pause
	\item Realizations of the transformations as functions. %\pause
	\item Some arithmetic results in the tiling and low-level transformations. %\pause
	\item Work on loops and add loop transformations.%\pause
	\item Connect the low-level language with CompCert (at which level?) % C or Clight?
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{}

\Ce{Thanks!}

\end{frame}

%------------------------------------------------------------------------------
%\frame{\titlepage}

%******************************************************************************
%******************************************************************************
%******************************************************************************

\end{document}
