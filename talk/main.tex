\def\macrosUseBeamer{}
\input{arthur}
\input{macros}

\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{multicol}

\newcommand\tab{$\hphantom{--}$}

\begin{document}


%******************************************************************************
%******************************************************************************
%******************************************************************************

\title{Verification of Data Layout Transformations}
\author[Ramon Fern\'{a}ndez Mir]{{\bf Ramon Fern\'{a}ndez Mir}\\ \vspace{1em} with Arthur Chargu√©raud }
\institute[]{Inria}
\date{17/09/2018}

\frame{\titlepage}

%******************************************************************************
%\framecontentdocument

%******************************************************************************
%******************************************************************************
%******************************************************************************
%\section{Separation Logic: a first example}

%\framecontentsection


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example}

\begin{figure}[H]
\centering
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/ITER_tokamak}
\caption{\footnotesize ITER tokamak}
\label{fig:figure1}
\end{minipage}%
\hspace{0.5cm}
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/plasma_physics}
\caption{\footnotesize Plasma physics}
\label{fig:figure2}
\end{minipage}%
\hspace{0.5cm}
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/PIC_simulation}
\caption{\footnotesize PIC simulation}
\label{fig:figure2}
\end{minipage}
\end{figure}

\bigskip

Challenges:
\begin{itemize}
	\item Exploit data-level parallelism.
	\item Use domain-specific knowledge of the code.
	\item Do it without introducing any bugs.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - initial code}

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    // Position
    float x, y, z;
    // Other fields
    float vx, vy, vz, c, m, v;
  } particle;
  
  particle data[NUM_PARTICLES];
  
  for (int i = 0; i < NUM_PARTICLES; i++) {
    // Some calculation
  }
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - splitting}

Suppose that the calculation uses mainly the position.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
    cold_fields *other;
  } particle;
  
  particle data[NUM_PARTICLES];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - peeling}

Further suppose that the intial `particle' record is not used as part of a dynamic data structure.

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
  } hot_fields;

  cold_fields other_data[NUM_PARTICLES];
  hot_fields pos_data[NUM_PARTICLES];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to SoA}

Now, say that we want to take advantage of vector instructions.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[NUM_PARTICLES]; 
    float y[NUM_PARTICLES];
    float z[NUM_PARTICLES];
  } hot_fields;

  hot_fields pos_data;
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to AoSoA}

But without reducing too much the locality between accesses to fields of the original struct.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[N]; 
    float y[N];
    float z[N];
  } hot_fields;

  hot_fields pos_data[NUM_PARTICLES / N];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - summary}

In short, the transformations we have seen are:
\begin{itemize}
	\item Splitting.
	\item Peeling.
	\item AoS to SoA.
	\item AoS to AoSoA.
\end{itemize}

\bigskip

Note that after all these changes, where we wrote:

\begin{lstlisting}[style=Cstyle]
  data[i].x 
\end{lstlisting}

Now we have to write:

\begin{lstlisting}[style=Cstyle]
  pos_data[i / N].x[i % N]
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Project goals}

\begin{itemize}
	\setlength\itemsep{1.5em}
	\item Find the basic transformations that combined give rise to the ones we are interested in.\\
	\item Formalize a C-like language with arrays, structs and pointers to apply these transformations.
	\begin{itemize}
		\item On a high-level, to simplify the proofs.
		\item On a low-level, to be closer to the semantics of C.
	\end{itemize}
	\item Define the transformations and prove their correctness.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations}

\begin{center}
\begin{minipage}{0.45\linewidth}
\textbf{\small 1. Field grouping}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b, c;
} s;

// After
typedef struct {
  int b, c;
} sg;

typedef struct {
  int a; sg fg;
} s;
\end{lstlisting}
\textbf{\small 2. Array tiling}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
int[N] a;

// After
int[B][N / B] a;
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.45\linewidth}
\textbf{\small 3. Adding indirection}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a; int *b;
} s;
\end{lstlisting}
\textbf{\small 4. AoS to SoA}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a[N]; int b[N];
} s;
\end{lstlisting}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - justification}

\begin{itemize}
	\setlength\itemsep{1.5em}
	\item \textbf{Peeling:} Field grouping twice.
	\item \textbf{Splitting:} Field grouping and then adding indirection on the field holding the group.
	\item \textbf{AoS to SoA:} AoS to SoA.
	\item \textbf{AoS to AoSoA:} Array tiling and then AoS to SoA on the tiles.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - values and terms}

\begin{coqs}
Inductive val : Type :=
  (* High-level *)
  | val_error : val
  | val_unit : val
  | val_uninitialized : val
  | val_bool : bool -> val
  | val_int : int -> val
  | val_double : int -> val
  | val_abstract_ptr : loc -> accesses -> val
  | val_array : typ -> list val -> val
  | val_struct : typ -> map field val -> val
  (* Low-level *)
  | val_concrete_ptr : loc -> offset -> val
  | val_words : list word -> val.
\end{coqs}

\begin{coqs}
Inductive trm : Type :=
  | trm_var : var -> trm
  | trm_val : val -> trm
  | trm_if : trm -> trm -> trm -> trm
  | trm_let : bind -> trm -> trm -> trm
  | trm_app : prim -> list trm -> trm
  | trm_while : trm -> trm -> trm
  | trm_for : var -> val -> val -> trm -> trm.
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - primitive operations}

\begin{coqs}
Inductive prim : Type :=
  (* High-level *)
  | prim_binop : binop -> prim
  | prim_get : typ -> prim
  | prim_set : typ -> prim
  | prim_new : typ -> prim
  | prim_new_array : typ -> prim
  | prim_struct_access : typ -> field -> prim
  | prim_array_access : typ -> prim
  | prim_struct_get : typ -> field -> prim
  | prim_array_get : typ -> prim
  (* Low-level *)
  | prim_ll_get : typ -> prim
  | prim_ll_set : typ -> prim
  | prim_ll_new : typ -> prim
  | prim_ll_access : typ -> prim.
\end{coqs}

Examples of the semantics of our language compared to C:

\begin{Verbatim}[fontsize=\scriptsize]
   get p   : *p                         array_access p i  : p + i
   set p v : *p = v                     struct_access p f : &(p->f)
   new T   : malloc(sizeof(T))          struct_get s f    : s.f
\end{Verbatim}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - typing}

Maybe a couple or three slides for this.

Give overview of typing.

Use this theorem to explain the different parts of semantics and typing.

\begin{coqs}
Theorem type_soundess : forall C LLC F m t v T G S m',
  red C LLC S m t m' v ->
  typing C LLC F G t T ->
  state_typing C LLC F m ->
  stack_typing C LLC F G S ->
  exists F', extends F F'
    /\  typing_val C LLC F' v T
    /\  state_typing C LLC F' m'.
\end{coqs}

Some language properties.

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - grouping}

group

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - tiling}

tiling

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - adding indirection}

adding indirection

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - AoS to SoA}

AoS to SoA

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - summary}

Peeling = 
Splitting =
AoS to SoA =
AoS to SoA =

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - proof}

statement and proof

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Project extent}

what has been done and what hasn't quite and statistics

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Future work}

for instance functions etc, combining them. Code realisations...

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Conclusion}

conclusion

\end{frame}


%******************************************************************************
%******************************************************************************
%******************************************************************************

\end{document}
