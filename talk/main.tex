\def\macrosUseBeamer{}
\input{arthur}
\input{macros}

\usepackage{fancyvrb}
\usepackage{multicol}

\newcommand\tab{$\hphantom{--}$}

\begin{document}


%******************************************************************************
%******************************************************************************
%******************************************************************************

\title{Verification of Data Layout Transformations}
\author[Ramon Fern\'{a}ndez Mir]{{\bf Ramon Fern\'{a}ndez Mir}\\ \vspace{1em} with Arthur Chargu√©raud }
\institute[]{Inria}
\date{17/09/2018}

\frame{\titlepage}

%******************************************************************************
%\framecontentdocument

%******************************************************************************
%******************************************************************************
%******************************************************************************
%\section{Separation Logic: a first example}

%\framecontentsection

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - initial code}

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    // Position
    float x, y, z;
    // Other fields
    float vx, vy, vz, c, m, v;
  } particle;
  
  particle data[NUM_PARTICLES];
  
  for (int i = 0; i < NUM_PARTICLES; i++) {
    // Some calculation
  }
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - splitting}

Suppose that the calculation uses mainly the position.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
    cold_fields *other;
  } particle;
  
  particle data[NUM_PARTICLES];
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - peeling}

Further suppose that the intial `particle' record is not used as part of a dynamic data structure.

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
  } hot_fields;

  cold_fields other_data[NUM_PARTICLES];
  hot_fields pos_data[NUM_PARTICLES];
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to SoA}

Now, say that we want to take advantage of vector instructions.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[NUM_PARTICLES]; 
    float y[NUM_PARTICLES];
    float z[NUM_PARTICLES];
  } hot_fields;

  hot_fields pos_data;
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to AoSoA}

But without reducing too much the locality between accesses to fields of the original struct.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[N]; 
    float y[N];
    float z[N];
  } hot_fields;

  hot_fields pos_data[NUM_PARTICLES / N];
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - summary}

In short, the transformations we have seen are:
\begin{itemize}
	\item Splitting.
	\item Peeling.
	\item AoS to SoA.
	\item AoS to AoSoA.
\end{itemize}

\bigskip

Note that after all these changes, where we wrote:

\begin{lstlisting}[style=Cstyle]
  data[i].x 
\end{lstlisting}

Now we have to write:

\begin{lstlisting}[style=Cstyle]
  pos_data[i / N].x[i % N]
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Project goals}

\begin{itemize}
	\setlength\itemsep{1.5em}
	\item Formalize a subset of C that captures the essential for these transformations.\\
	\item Find the basic transformations that combined give rise to the ones we are interested in.\\
	\item Define them and prove their correctness.
	%(transient like clojure)
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - values and terms}

\begin{coqs}
Inductive val : Type :=
  (* High-level *)
  | val_error : val
  | val_unit : val
  | val_uninitialized : val
  | val_bool : bool -> val
  | val_int : int -> val
  | val_double : int -> val
  | val_abstract_ptr : loc -> accesses -> val
  | val_array : typ -> list val -> val
  | val_struct : typ -> map field val -> val
  (* Low-level *)
  | val_concrete_ptr : loc -> offset -> val
  | val_words : list word -> val.
\end{coqs}

\begin{coqs}
Inductive trm : Type :=
  | trm_var : var -> trm
  | trm_val : val -> trm
  | trm_if : trm -> trm -> trm -> trm
  | trm_let : bind -> trm -> trm -> trm
  | trm_app : prim -> list trm -> trm
  | trm_while : trm -> trm -> trm
  | trm_for : var -> val -> val -> trm -> trm.
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - primitive operations}

\begin{coqs}
Inductive prim : Type :=
  (* High-level *)
  | prim_binop : binop -> prim
  | prim_get : typ -> prim
  | prim_set : typ -> prim
  | prim_new : typ -> prim
  | prim_new_array : typ -> prim
  | prim_struct_access : typ -> field -> prim
  | prim_array_access : typ -> prim
  | prim_struct_get : typ -> field -> prim
  | prim_array_get : typ -> prim
  (* Low-level *)
  | prim_ll_get : typ -> prim
  | prim_ll_set : typ -> prim
  | prim_ll_new : typ -> prim
  | prim_ll_access : typ -> prim.
\end{coqs}

Examples of the semantics of our language compared to C:

\begin{Verbatim}[fontsize=\scriptsize]
   get p   : *p                         array_access p i  : p + i
   set p v : *p = v                     struct_access p f : &(p->f)
   new T   : malloc(sizeof(T))          struct_get s f    : s.f
\end{Verbatim}

\end{frame}



%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Related Work}

\begin{tabular}{llll}
 \textbf{Structure} & \textbf{Memory} & \textbf{Time} & \textbf{Limitations}\\
Arrays & $1\times$ & $1\times$ & concat/split/resize: $O(n)$ \\
Vectors & $2-4\times$ & $2\times$ & concat/split: $O(n)$\\
% Vectors: 2x time because of copies
Lists & $3\times$ & $3\times$ & concat/split/random access $O(n)$\\
% Lists: 3x time on large sequences because of pointers
Finger trees & $>3\times$ & $>3\times$ & Not transient\\
% worse than lists
% bad constant factors, better with chunks
Ropes & ? & ? & More complex access to ends, \\
& & & not automatically balanced\\
% pas de borne sur la memoire et le temps (degenere vite)
% data is deeper, catenable chunks not next to each other, balancing (split can lead to very unbalanced tree), no access to ends, not transient
Chunked Seq & $<1.2 \times$ & $<2 \times$ &
\end{tabular}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Interface}

Chunks: fixed capacity arrays in which elements are stored\\
K = size of chunks

\bigskip

\begin{tabular}{lll}
 \textbf{Operation} & \textbf{Ephemeral} & \textbf{Persistent}\\
 &&\\
push/pop/front/back & $O(1 + \frac{1}{K}\log_K n)$ & $O(K + \frac{1}{K}\log_K n)$\\
\tab usual case & $O(1)$ & $O(1)$\\
concat/split/get/set & $O(K \log_Kn)$ & $O(K \log_Kn)$\\
iter/fold/... & $O(n)$ & $O(n)$\\
% mettre en centre
Ephemeral \textrightarrow Persistent & & \\
\tab destructive & \tab \tab \tab $O(1$) & \\
\tab nondestructive  & \tab \tab \tab $O(K)$ & \\
Persistent \textrightarrow Ephemeral & \tab \tab \tab $O(K)$ &
\end{tabular}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Tree Structure}
%accroississement exponentiel de la taille des elements, donc pas beaucoup de niveaux
%\Imagew{10}{tree_structure.pdf}
[image]

\end{frame}



%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Sequence Representation - persistent}

\textbf{Pchunk}:\\
Fixed capacity persistent sequence\\
Implemented using a view on a shared ``support" chunk
%A pchunk is a small (size $<$ K) persistent sequence
%implemented using a view on a shared ``support" chunk.

\begin{caml}
  type 'a pchunk = {
    support : 'a chunk;
    mutable view : segment; }
\end{caml}

\begin{caml}
type segment = int * int
\end{caml}

\medskip

The shared chunk is reusable when popping or when pushing past its bounds. Other push cases need copy-on-write.

\medskip

Pops are always O(1), pushes are in amortized O(1) if iterated.

\begin{caml}
 type 'a pseq =
 | Empty
 | Struct of 'a pchunk * ('a pchunk) seq * 'a pchunk
\end{caml}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Versions}

\textbf{Goal:} Work on pchunks with in-place updates in ephemeral sequences

\smallskip

\textbf{Solution:} Maintain whether a chunk is shared or uniquely possessed in ephemeral sequences

\medskip

\textbf{Invariants:} \\
Persistent: all chunks are marked false\\
Ephemeral: some are false and shared, some are true and were created in this sequence

\smallskip

Ephemeral \textrightarrow persistent = mark all chunks back to false\\
%other option: use a list; not great because not all pchunks have the same type
%Persistent \textrightarrow Ephemeral:\\
%\tab all chunks are ``false", ``true" chunks can be created\\
%Ephemeral \textrightarrow Persistent:\\
%\tab all chunks must be marked ``false"

%all chunks have a version, match = in-place update etc
Version number trick enables this to be done in constant time.\\

\begin{caml}
  type 'a pchunk = {
  	version : version;
   support : 'a chunk;
   mutable view : segment; }
\end{caml}

\bigskip

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transient Sequences - Types}

\begin{caml}
type 'a seq = {
  mutable version : version;
  mutable front : 'a chunk;
  mutable middle : ('a pchunk) pseq;
  mutable back : 'a chunk;
}
\end{caml}

\begin{caml}
type 'a pseq =
| Empty of 'a
| Struct of 'a pchunk * ('a pchunk) pseq * 'a pchunk
\end{caml}

\medskip

Note: Persistent sequence version number is stored in back chunk.

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Summary and Additional Fields}

%\resizebox{\textwidth}{!}{<content>}
%type 'a t = | Empty of 'a
 %           | Struct of weight * 'a pchunk * ('a pchunk) t * 'a pchunk
\begin{multicols}{2}

\begin{camls}
type 'a chunk = {
  mutable head : int;
  mutable size : int;
  mutable data : 'a array;
  default : 'a; }
\end{camls}

\begin{camls}
type 'a pchunk = {
  version : version;
  support : 'a chunk;
  mutable view : segment;
  mutable weight : weight; }
\end{camls}

\end{multicols}

\begin{camls}
type 'a seq = {
  mutable version : version;
  mutable front : 'a chunk;
  mutable free_front : ('a chunk) option;
  mutable middle : ('a pchunk) PWSeq.t;
  mutable free_back : ('a chunk) option;
  mutable back : 'a chunk;
}
\end{camls}

\begin{camls}
type 'a pseq =
	 | Empty of 'a
    | Struct of weight * 'a pchunk * ('a pchunk) t * 'a pchunk
\end{camls}

\end{frame}

%******************************************************************************
%******************************************************************************
%******************************************************************************

\end{document}

