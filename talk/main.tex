\def\macrosUseBeamer{}
\input{arthur}
\input{macros}

\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{multicol}

\newcommand\tab{$\hphantom{--}$}

\begin{document}


%******************************************************************************
%******************************************************************************
%******************************************************************************

\title{Verification of Data Layout Transformations}
\author[Ramon Fern\'{a}ndez Mir]{{\bf Ramon Fern\'{a}ndez Mir}\\ \vspace{1em} with Arthur Chargu√©raud }
\institute[]{Inria}
\date{17/09/2018}

\frame{\titlepage}

%******************************************************************************
%\framecontentdocument

%******************************************************************************
%******************************************************************************
%******************************************************************************
%\section{Separation Logic: a first example}

%\framecontentsection


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example}

\begin{figure}[H]
\centering
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/ITER_tokamak}
\caption{\footnotesize ITER tokamak}
\label{fig:figure1}
\end{minipage}%
\hspace{0.5cm}
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/plasma_physics}
\caption{\footnotesize Plasma physics}
\label{fig:figure2}
\end{minipage}%
\hspace{0.5cm}
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/PIC_simulation}
\caption{\footnotesize PIC simulation}
\label{fig:figure2}
\end{minipage}
\end{figure}

\bigskip

Challenges:
\begin{itemize}
	\item Exploit data-level parallelism.
	\item Use domain-specific knowledge of the code.
	\item Do it without introducing any bugs.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - initial code}

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    // Position
    float x, y, z;
    // Other fields
    float vx, vy, vz, c, m, v;
  } particle;
  
  particle data[NUM_PARTICLES];
  
  for (int i = 0; i < NUM_PARTICLES; i++) {
    // Some calculation
  }
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - splitting}

Suppose that the calculation uses mainly the position.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
    cold_fields *other;
  } particle;
  
  particle data[NUM_PARTICLES];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - peeling}

Further suppose that the intial `particle' record is not used as part of a dynamic data structure.

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
  } hot_fields;

  cold_fields other_data[NUM_PARTICLES];
  hot_fields pos_data[NUM_PARTICLES];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to SoA}

Now, say that we want to take advantage of vector instructions.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[NUM_PARTICLES]; 
    float y[NUM_PARTICLES];
    float z[NUM_PARTICLES];
  } hot_fields;

  hot_fields pos_data;
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to AoSoA}

But without reducing too much the locality between accesses to fields of the original struct.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[N]; 
    float y[N];
    float z[N];
  } hot_fields;

  hot_fields pos_data[NUM_PARTICLES / N];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - summary}

In short, the transformations we have seen are:
\begin{itemize}
	\item Splitting.
	\item Peeling.
	\item AoS to SoA.
	\item AoS to AoSoA.
\end{itemize}

\bigskip

Note that after all these changes, where we wrote:

\begin{lstlisting}[style=Cstyle]
  data[i].x 
\end{lstlisting}

Now we have to write:

\begin{lstlisting}[style=Cstyle]
  pos_data[i / N].x[i % N]
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Project goals}

\begin{itemize}
	\setlength\itemsep{1.5em}
	\item Find the basic transformations that combined give rise to the ones we are interested in.\\
	\item Formalize a C-like language with arrays, structs and pointers.
	\begin{itemize}
		\item On a high-level, to simplify the proofs.
		\item On a low-level, to be closer to the semantics of C.
	\end{itemize}
	\item Define the transformations and prove their correctness.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations}

\begin{center}
\begin{minipage}{0.45\linewidth}
\textbf{\small 1. Field grouping}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b, c;
} s;

// After
typedef struct {
  int b, c;
} sg;

typedef struct {
  int a; sg fg;
} s';
\end{lstlisting}
\textbf{\small 2. Array tiling}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
int a[N];

// After
int a'[N / B][B];
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.45\linewidth}
\textbf{\small 3. Adding indirection}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a; int *b;
} s';
\end{lstlisting}
\textbf{\small 4. AoS to SoA}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a[N]; int b[N];
} s;
\end{lstlisting}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - grouping}

\begin{center}
\begin{minipage}{0.3\linewidth}
\textbf{\small 1. Field grouping}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b, c;
} s;

// After
typedef struct {
  int b, c;
} sg;

typedef struct {
  int a; sg fg;
} s';
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{images/grouping}
\end{figure}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - tiling}

\begin{center}
\begin{minipage}{0.3\linewidth}
\textbf{\small 2. Array tiling}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
int a[N];

// After
int a'[N / B][B];
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{images/tiling}
\end{figure}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - indirection}

\begin{center}
\begin{minipage}{0.3\linewidth}
\textbf{\small 3. Adding indirection}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a; int *b;
} s';
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{images/indirection}
\end{figure}
\end{minipage}
\end{center}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - AoS to SoA}

\begin{center}
\begin{minipage}{0.3\linewidth}
\textbf{\small 4. AoS to SoA}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a[N]; int b[N];
} s;
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{images/soa}
\end{figure}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - justification}

\begin{itemize}
	\setlength\itemsep{1.5em}
	\item \textbf{Peeling:} Field grouping twice.
	\item \textbf{Splitting:} Field grouping and then adding indirection on the field holding the group.
	\item \textbf{AoS to SoA:} AoS to SoA.
	\item \textbf{AoS to AoSoA:} Array tiling and then AoS to SoA on the tiles.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - values and terms}

\begin{coqs}
Inductive val : Type :=
  | val_error : val
  | val_unit : val
  | val_uninitialized : val
  | val_bool : bool -> val
  | val_int : int -> val
  | val_double : int -> val
  | val_abstract_ptr : loc -> accesses -> val
  | val_array : typ -> list val -> val
  | val_struct : typ -> map field val -> val
\end{coqs}

\begin{coqs}
Inductive trm : Type :=
  | trm_var : var -> trm
  | trm_val : val -> trm
  | trm_if : trm -> trm -> trm -> trm
  | trm_let : bind -> trm -> trm -> trm
  | trm_app : prim -> list trm -> trm
  | trm_while : trm -> trm -> trm
  | trm_for : var -> val -> val -> trm -> trm.
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - primitive operations}

\begin{coqs}
  Inductive prim : Type :=
    | prim_binop : binop -> prim
    | prim_get : typ -> prim
    | prim_set : typ -> prim
    | prim_new : typ -> prim
    | prim_new_array : typ -> prim
    | prim_struct_access : typ -> field -> prim
    | prim_array_access : typ -> prim
    | prim_struct_get : typ -> field -> prim
    | prim_array_get : typ -> prim
\end{coqs}

Examples of the semantics of our language compared to C:

\begin{Verbatim}[fontsize=\scriptsize]
   get p   : *p                         array_access p i  : p + i
   set p v : *p = v                     struct_access p f : &(p->f)
   new T   : malloc(sizeof(T))          struct_get s f    : s.f
\end{Verbatim}

where pointers are represented as pairs:

\begin{Verbatim}[fontsize=\scriptsize]
   (l, [access_field T f, access_array T' i]) 
\end{Verbatim}

which would correspond to the address:

\begin{Verbatim}[fontsize=\scriptsize]
   l + field_offset(f) + i * sizeof(T')
\end{Verbatim}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - semantics}

%Maybe a couple or three slides for this.

%Give overview of typing.

%Use this theorem to explain the different parts of semantics and typing.

Some crucial definitions:

\begin{coqs}
  Definition typdefctx := map typvar typ.

  Record ll_typdefctx := make_ll_typdefctx {
    typvar_sizes				: map typvar size;
    fields_offsets	: map typvar (map field offset);
    fields_order				: map typvar (list field) }.
  
  Definition stack := Ctx.ctx val.

  Definition state := map loc val.
\end{coqs}

\bigskip

And the relation that defines the big-step reduction rules:

\begin{coqs}
  red 	<==		typdefctx |times 	ll_typdefctx |times 	stack |times 	state |times 	trm |times	state |times	val
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - typing}

The allowed types are:

\begin{coqs}
  Inductive typ : Type :=
    | typ_unit : typ
    | typ_int : typ
    | typ_double : typ
    | typ_bool : typ
    | typ_ptr : typ -> typ
    | typ_array : typ -> option size -> typ
    | typ_struct : map field typ -> typ
    | typ_var : typvar -> typ.
\end{coqs}

\bigskip

With their corresponding definitions (analogous to stack and state):

\begin{coqs}
  Definition gamma : Ctx.ctx typ.

  Definition phi : map loc typ.
\end{coqs}

\bigskip

Typing is defined as the following relation:

\begin{coqs}
  typing		<==		typdefctx |times 	gamma |times 	phi |times 	trm |times	typ
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - properties}

Need to think of something...

An approximation to type safety:
\begin{coq}
  Theorem type_soundness : forall C LLC m t v T,
    red C LLC nil empty t m v ->
    typing C nil empty t T ->
    exists f, typing_val C f v T 
  	  /\  state_typing C f m.
\end{coq}

\bigskip



\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Field grouping}

The arguments of the transformation are:
\begin{itemize}
	\item The name of the struct being changed.
	\item The fields being grouped.
	\item The name of the new struct that will contain said fields.
	\item The new field holding the new struct.
\end{itemize}

\bigskip

These are used to define a transformation for:
\\[0.75em]
\begin{minipage}{0.45\linewidth}
\begin{itemize}
	\item type definitions contexts,
	\item accesses,
	\item values,
\end{itemize}
\end{minipage}%
\begin{minipage}{0.45\linewidth}
\begin{itemize}
	\item terms,
	\item states and
	\item stacks.
\end{itemize}
\end{minipage}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Field grouping - typdefctx}

We `update' the type definitions context as follows:

\begin{coqs}
Inductive tr_typdefctx (gt:group_tr) : typdefctx -> typdefctx -> Prop :=
  | tr_typdefctx_intro : forall Tfs Tfs' Tfsg Tt fs Tg fg C C',
      gt = make_group_tr Tt fs Tg fg ->
      dom C' = dom C \u \{Tg} ->
      (* The original map from fields to types. *)
      C[Tt] = typ_struct Tfs ->
      (* The map for the new struct and for the grouped fields. *)
      tr_struct_map gt Tfs Tfs' Tfsg ->
      C'[Tt] = typ_struct Tfs' ->
      C'[Tg] = typ_struct Tfsg ->
      (* The other type variables stay the same. *)      
      (forall T,
        T \indom C ->
        T <> Tt ->
        C'[T] = C[T]) ->
      tr_typdefctx gt C C'.
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Field grouping - accesses}

For accesses, if we look at the interesting case:

\begin{coqs}
Inductive tr_accesses (gt:group_tr) : accesses -> accesses -> Prop :=
  | tr_accesses_field_group : forall Tt fs fg Tg f a0 p a1 a2 p',
      gt = make_group_tr Tt fs Tg fg ->
      f \in fs ->
      (* The access s.f *)
      a0 = access_field (typ_var Tt) f ->
      (* Becomes s'.fg.f *)
      a1 = access_field (typ_var Tt) fg ->
      a2 = access_field (typ_var Tg) f ->
      tr_accesses gt p p' ->
      tr_accesses gt (a0::p) (a1::a2::p')
\end{coqs}

\bigskip

This is used in:

\begin{coqs}
Inductive tr_val (gt:group_tr) : val -> val -> Prop :=
  | tr_val_abstract_ptr : forall l p p',
      tr_accesses gt p p' ->
      tr_val gt (val_abstract_ptr l p) (val_abstract_ptr l p')
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Field grouping - accesses}

For accesses, if we look at the interesting case:

\begin{coqs}
  | tr_val_struct_group : forall Tt Tg s s' fg fs sg,
      gt = make_group_tr Tt fs Tg fg ->
      fs \c dom s ->
      fg \notindom s ->
      dom s' = (dom s \- fs) \u \{fg} ->
      dom sg = fs ->
      (forall f,
        f \indom sg ->
        tr_val gt s[f] sg[f]) ->
      (forall f,
        f \notin fs ->
        f \indom s ->
        tr_val gt s[f] s'[f]) ->
      s'[fg] = val_struct (typ_var Tg) sg ->
      tr_val gt (val_struct (typ_var Tt) s) (val_struct (typ_var Tt) s')
\end{coqs}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - tiling}

tiling

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - AoS to SoA}

AoS to SoA

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - proof}

statement and proof

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{High-to-low level transformation}

A few slides on this.

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Project extent}

what has been done and what hasn't quite and statistics

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Future work}

for instance functions etc, combining them. Code realisations...

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Conclusion}

conclusion

\end{frame}


%******************************************************************************
%******************************************************************************
%******************************************************************************

\end{document}
