\def\macrosUseBeamer{}
\input{arthur}
\input{macros}

\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{multicol}

\newcommand\tab{$\hphantom{--}$}

\begin{document}


%******************************************************************************
%******************************************************************************
%******************************************************************************

\title{Verification of Data Layout Transformations}
\author[Ramon Fern\'{a}ndez Mir]{{\bf Ramon Fern\'{a}ndez Mir}\\ \vspace{1em} with Arthur Chargu√©raud }
\institute[]{Inria}
\date{17/09/2018}

\frame{\titlepage}

%******************************************************************************
%\framecontentdocument

%******************************************************************************
%******************************************************************************
%******************************************************************************
%\section{Separation Logic: a first example}

%\framecontentsection


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example}

\begin{figure}[H]
\centering
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/ITER_tokamak}
\caption{\footnotesize ITER tokamak}
\label{fig:figure1}
\end{minipage}%
\hspace{0.5cm}
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/plasma_physics}
\caption{\footnotesize Plasma physics}
\label{fig:figure2}
\end{minipage}%
\hspace{0.5cm}
\begin{minipage}{0.275\linewidth}
\centering
\includegraphics[width=\textwidth, height=3.25cm]{images/PIC_simulation}
\caption{\footnotesize PIC simulation}
\label{fig:figure2}
\end{minipage}
\end{figure}

\bigskip

Challenges:
\begin{itemize}
	\item Exploit data-level parallelism.
	\item Use domain-specific knowledge of the code.
	\item Do it without introducing any bugs.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - initial code}

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    // Position
    float x, y, z;
    // Other fields
    float vx, vy, vz, c, m, v;
  } particle;
  
  particle data[NUM_PARTICLES];
  
  for (int i = 0; i < NUM_PARTICLES; i++) {
    // Some calculation
  }
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - splitting}

Suppose that the calculation uses mainly the position.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
    cold_fields *other;
  } particle;
  
  particle data[NUM_PARTICLES];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - peeling}

Further suppose that the intial `particle' record is not used as part of a dynamic data structure.

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float vx, vy, vz, c, m, v;
  } cold_fields;

  typedef struct {
    float x, y, z;
  } hot_fields;

  cold_fields other_data[NUM_PARTICLES];
  hot_fields pos_data[NUM_PARTICLES];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to SoA}

Now, say that we want to take advantage of vector instructions.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[NUM_PARTICLES]; 
    float y[NUM_PARTICLES];
    float z[NUM_PARTICLES];
  } hot_fields;

  hot_fields pos_data;
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - AoS to AoSoA}

But without reducing too much the locality between accesses to fields of the original struct.

\bigskip

\begin{lstlisting}[style=Cstyle]
  typedef struct {
    float x[N]; 
    float y[N];
    float z[N];
  } hot_fields;

  hot_fields pos_data[NUM_PARTICLES / N];
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivating example - summary}

In short, the transformations we have seen are:
\begin{itemize}
	\item Splitting.
	\item Peeling.
	\item AoS to SoA.
	\item AoS to AoSoA.
\end{itemize}

\bigskip

Note that after all these changes, where we wrote:

\begin{lstlisting}[style=Cstyle]
  data[i].x 
\end{lstlisting}

Now we have to write:

\begin{lstlisting}[style=Cstyle]
  pos_data[i / N].x[i % N]
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Project goals}

\begin{itemize}
	\setlength\itemsep{1.5em}
	\item Find the basic transformations that combined give rise to the ones we are interested in.\\
	\item Formalize a C-like language with arrays, structs and pointers.
	\begin{itemize}
		\item On a high-level, to simplify the proofs.
		\item On a low-level, to be closer to the semantics of C.
	\end{itemize}
	\item Define the transformations and prove their correctness.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations}

\begin{center}
\begin{minipage}{0.45\linewidth}
\textbf{\small 1. Field grouping}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b, c;
} s;

// After
typedef struct {
  int b, c;
} sg;

typedef struct {
  int a; sg fg;
} s;
\end{lstlisting}
\textbf{\small 2. Array tiling}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
int[N] a;

// After
int[B][N / B] a;
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.45\linewidth}
\textbf{\small 3. Adding indirection}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a; int *b;
} s;
\end{lstlisting}
\textbf{\small 4. AoS to SoA}
\begin{lstlisting}[style=Cstyle, basicstyle=\scriptsize]
// Before
typedef struct {
  int a, b;
} s;

// After
typedef struct {
  int a[N]; int b[N];
} s;
\end{lstlisting}
\end{minipage}
\end{center}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Basic transformations - justification}

\begin{itemize}
	\setlength\itemsep{1.5em}
	\item \textbf{Peeling:} Field grouping twice.
	\item \textbf{Splitting:} Field grouping and then adding indirection on the field holding the group.
	\item \textbf{AoS to SoA:} AoS to SoA.
	\item \textbf{AoS to AoSoA:} Array tiling and then AoS to SoA on the tiles.
\end{itemize}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - values and terms}

\begin{coqs}
Inductive val : Type :=
  | val_error : val
  | val_unit : val
  | val_uninitialized : val
  | val_bool : bool -> val
  | val_int : int -> val
  | val_double : int -> val
  | val_abstract_ptr : loc -> accesses -> val
  | val_array : typ -> list val -> val
  | val_struct : typ -> map field val -> val
\end{coqs}

\begin{coqs}
Inductive trm : Type :=
  | trm_var : var -> trm
  | trm_val : val -> trm
  | trm_if : trm -> trm -> trm -> trm
  | trm_let : bind -> trm -> trm -> trm
  | trm_app : prim -> list trm -> trm
  | trm_while : trm -> trm -> trm
  | trm_for : var -> val -> val -> trm -> trm.
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - primitive operations}

\begin{coqs}
  Inductive prim : Type :=
    | prim_binop : binop -> prim
    | prim_get : typ -> prim
    | prim_set : typ -> prim
    | prim_new : typ -> prim
    | prim_new_array : typ -> prim
    | prim_struct_access : typ -> field -> prim
    | prim_array_access : typ -> prim
    | prim_struct_get : typ -> field -> prim
    | prim_array_get : typ -> prim
\end{coqs}

Examples of the semantics of our language compared to C:

\begin{Verbatim}[fontsize=\scriptsize]
   get p   : *p                         array_access p i  : p + i
   set p v : *p = v                     struct_access p f : &(p->f)
   new T   : malloc(sizeof(T))          struct_get s f    : s.f
\end{Verbatim}

where pointers are represented as pairs:

\begin{Verbatim}[fontsize=\scriptsize]
   (l, [access_field T f, access_array T' i]) 
\end{Verbatim}

which would correspond to the address:

\begin{Verbatim}[fontsize=\scriptsize]
   l + field_offset(f) + i * sizeof(T')
\end{Verbatim}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - semantics}

%Maybe a couple or three slides for this.

%Give overview of typing.

%Use this theorem to explain the different parts of semantics and typing.

Some crucial definitions:

\begin{coqs}
  Definition typdefctx := map typvar typ.

  Record ll_typdefctx := make_ll_typdefctx {
    typvar_sizes				: map typvar size;
    fields_offsets	: map typvar (map field offset);
    fields_order				: map typvar (list field) }.
  
  Definition stack := Ctx.ctx val.

  Definition state := map loc val.
\end{coqs}

\bigskip

And the relation that defines the big-step reduction rules:

\begin{coqs}
  red 	<==		typdefctx |times 	ll_typdefctx |times 	stack |times 	state |times 	trm |times	state |times	val
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - typing}

The allowed types are:

\begin{coqs}
  Inductive typ : Type :=
    | typ_unit : typ
    | typ_int : typ
    | typ_double : typ
    | typ_bool : typ
    | typ_ptr : typ -> typ
    | typ_array : typ -> option size -> typ
    | typ_struct : map field typ -> typ
    | typ_var : typvar -> typ.
\end{coqs}

\bigskip

With their corresponding definitions (analogous to stack and state):

\begin{coqs}
  Definition gamma : Ctx.ctx typ.

  Definition phi : map loc typ.
\end{coqs}

\bigskip

Typing is defined as the following relation:

\begin{coqs}
  typing		<==		typdefctx |times 	gamma |times 	phi |times 	trm |times	typ
\end{coqs}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Language overview - properties}

Need to think of something...

An approximation to type safety:
\begin{coq}
  Theorem type_soundness : forall C LLC m t v T,
    red C LLC nil empty t m v ->
    typing C nil empty t T ->
    exists f, typing_val C f v T 
  	  /\  state_typing C f m.
\end{coq}

\bigskip



\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - grouping}

group

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - tiling}

tiling

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - AoS to SoA}

AoS to SoA

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transformations - proof}

statement and proof

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{High-to-low level transformation}

A few slides on this.

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Project extent}

what has been done and what hasn't quite and statistics

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Future work}

for instance functions etc, combining them. Code realisations...

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Conclusion}

conclusion

\end{frame}


%******************************************************************************
%******************************************************************************
%******************************************************************************

\end{document}
