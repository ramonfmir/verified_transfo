\def\macrosUseBeamer{}
\input{arthur}
\input{macros}


\usepackage{multicol}

\newcommand\tab{$\hphantom{--}$}

\begin{document}


%******************************************************************************
%******************************************************************************
%******************************************************************************

\title{Transient Chunked Sequences}
\author[Émilie Guermeur]{{\bf Émilie Guermeur}\\ \vspace{1em} with Arthur Charguéraud and François Pottier }
\institute[]{Inria}
\date{2018/06/19}

\frame{\titlepage}

%******************************************************************************
%\framecontentdocument

%******************************************************************************
%******************************************************************************
%******************************************************************************
%\section{Separation Logic: a first example}

%\framecontentsection

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Demo Coq}

\begin{coq}
  Lemma foo : forall x, exists y, x = y.
  Proof using.
    foo_solved.
  Qed.
\end{coq}

\begin{coqs}
  Lemma bar : forall x, exists y, x = y.
  Proof using.
    bar_solved.
  Qed.
\end{coqs}

\end{frame}



%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Motivation}

\begin{itemize}
	\setlength\itemsep{1.5em}
	\item To have an efficient data structure for stacks, queues, deques, sequences, catenable sequences, random access sequences, strings\\
	\item Both ephemeral and persistent versions with full persistence\\
	\item Convert between ephemeral and persistent versions in constant time
	%(transient like clojure)
\end{itemize}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Related Work}

\begin{tabular}{llll}
 \textbf{Structure} & \textbf{Memory} & \textbf{Time} & \textbf{Limitations}\\
Arrays & $1\times$ & $1\times$ & concat/split/resize: $O(n)$ \\
Vectors & $2-4\times$ & $2\times$ & concat/split: $O(n)$\\
% Vectors: 2x time because of copies
Lists & $3\times$ & $3\times$ & concat/split/random access $O(n)$\\
% Lists: 3x time on large sequences because of pointers
Finger trees & $>3\times$ & $>3\times$ & Not transient\\
% worse than lists
% bad constant factors, better with chunks
Ropes & ? & ? & More complex access to ends, \\
& & & not automatically balanced\\
% pas de borne sur la memoire et le temps (degenere vite)
% data is deeper, catenable chunks not next to each other, balancing (split can lead to very unbalanced tree), no access to ends, not transient
Chunked Seq & $<1.2 \times$ & $<2 \times$ &
\end{tabular}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Interface}

Chunks: fixed capacity arrays in which elements are stored\\
K = size of chunks

\bigskip

\begin{tabular}{lll}
 \textbf{Operation} & \textbf{Ephemeral} & \textbf{Persistent}\\
 &&\\
push/pop/front/back & $O(1 + \frac{1}{K}\log_K n)$ & $O(K + \frac{1}{K}\log_K n)$\\
\tab usual case & $O(1)$ & $O(1)$\\
concat/split/get/set & $O(K \log_Kn)$ & $O(K \log_Kn)$\\
iter/fold/... & $O(n)$ & $O(n)$\\
% mettre en centre
Ephemeral \textrightarrow Persistent & & \\
\tab destructive & \tab \tab \tab $O(1$) & \\
\tab nondestructive  & \tab \tab \tab $O(K)$ & \\
Persistent \textrightarrow Ephemeral & \tab \tab \tab $O(K)$ &
\end{tabular}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Chunked Sequence - key idea}

%These types are not final
\begin{caml}
  type 'a chunk = {
    data : 'a array;
    mutable head : head;
    mutable size : int; }
\end{caml}

\begin{caml}
 type 'a seq =
 |  Empty
 | Struct of 'a chunk * ('a chunk) seq * 'a chunk
\end{caml}

\end{frame}


%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Tree Structure}
%accroississement exponentiel de la taille des elements, donc pas beaucoup de niveaux
%\Imagew{10}{tree_structure.pdf}
[image]

\end{frame}



%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Sequence Representation - persistent}

\textbf{Pchunk}:\\
Fixed capacity persistent sequence\\
Implemented using a view on a shared ``support" chunk
%A pchunk is a small (size $<$ K) persistent sequence
%implemented using a view on a shared ``support" chunk.

\begin{caml}
  type 'a pchunk = {
    support : 'a chunk;
    mutable view : segment; }
\end{caml}

\begin{caml}
type segment = int * int
\end{caml}

\medskip

The shared chunk is reusable when popping or when pushing past its bounds. Other push cases need copy-on-write.

\medskip

Pops are always O(1), pushes are in amortized O(1) if iterated.

\begin{caml}
 type 'a pseq =
 | Empty
 | Struct of 'a pchunk * ('a pchunk) seq * 'a pchunk
\end{caml}

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Versions}

\textbf{Goal:} Work on pchunks with in-place updates in ephemeral sequences

\smallskip

\textbf{Solution:} Maintain whether a chunk is shared or uniquely possessed in ephemeral sequences

\medskip

\textbf{Invariants:} \\
Persistent: all chunks are marked false\\
Ephemeral: some are false and shared, some are true and were created in this sequence

\smallskip

Ephemeral \textrightarrow persistent = mark all chunks back to false\\
%other option: use a list; not great because not all pchunks have the same type
%Persistent \textrightarrow Ephemeral:\\
%\tab all chunks are ``false", ``true" chunks can be created\\
%Ephemeral \textrightarrow Persistent:\\
%\tab all chunks must be marked ``false"

%all chunks have a version, match = in-place update etc
Version number trick enables this to be done in constant time.\\

\begin{caml}
  type 'a pchunk = {
  	version : version;
   support : 'a chunk;
   mutable view : segment; }
\end{caml}

\bigskip

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Transient Sequences - Types}

\begin{caml}
type 'a seq = {
  mutable version : version;
  mutable front : 'a chunk;
  mutable middle : ('a pchunk) pseq;
  mutable back : 'a chunk;
}
\end{caml}

\begin{caml}
type 'a pseq =
| Empty of 'a
| Struct of 'a pchunk * ('a pchunk) pseq * 'a pchunk
\end{caml}

\medskip

Note: Persistent sequence version number is stored in back chunk.

\end{frame}

%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Summary and Additional Fields}

%\resizebox{\textwidth}{!}{<content>}
%type 'a t = | Empty of 'a
 %           | Struct of weight * 'a pchunk * ('a pchunk) t * 'a pchunk
\begin{multicols}{2}

\begin{camls}
type 'a chunk = {
  mutable head : int;
  mutable size : int;
  mutable data : 'a array;
  default : 'a; }
\end{camls}

\begin{camls}
type 'a pchunk = {
  version : version;
  support : 'a chunk;
  mutable view : segment;
  mutable weight : weight; }
\end{camls}

\end{multicols}

\begin{camls}
type 'a seq = {
  mutable version : version;
  mutable front : 'a chunk;
  mutable free_front : ('a chunk) option;
  mutable middle : ('a pchunk) PWSeq.t;
  mutable free_back : ('a chunk) option;
  mutable back : 'a chunk;
}
\end{camls}

\begin{camls}
type 'a pseq =
	 | Empty of 'a
    | Struct of weight * 'a pchunk * ('a pchunk) t * 'a pchunk
\end{camls}

\end{frame}

%******************************************************************************
%******************************************************************************
%******************************************************************************

\end{document}

